---
phase: 03-benchmarks-validation
plan: 01
type: execute
---

<objective>
Demonstrate IIO sensor filtering at kernel level via BPF — reject out-of-range readings before userspace sees them.

Purpose: Prove the sensor filtering thesis — BPF programs can filter noisy sensor data at kernel level, reducing userspace processing load. The simulated accelerometer provides data; BPF rejects invalid readings.
Output: iio_demo with BPF filter program + ringbuf event stream for valid readings, running in QEMU.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@kernel/src/driver/iio.rs
@userspace/iio_demo/src/main.rs
@kernel/src/bpf/helpers.rs
@kernel/src/bpf/mod.rs
@kernel/src/lib.rs
@kernel/crates/kernel_bpf/src/attach/iio.rs
@userspace/minilib/src/lib.rs

**Prior context:**
- IIO driver has simulated accelerometer generating events (counter 0-999)
- dispatch_event() uses lock-free BPF execution (02-01 fix)
- IioEvent struct: timestamp, device_id, channel, value, scale, offset
- iio_demo exists but minimal — just loads 2-instruction program returning event value
- init_simulated_device() spawns kernel background task generating events
- Need to wire IIO init into kernel boot and enhance the demo

**Helper IDs:**
- bpf_ktime_get_ns=1, bpf_trace_printk=2, bpf_map_lookup_elem=3
- bpf_map_update_elem=4, bpf_ringbuf_output=6
- BPF_RINGBUF_POLL=37, BPF_MAP_CREATE=1, BPF_PROG_LOAD=5, BPF_PROG_ATTACH=8
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance iio_demo with BPF filtering and ringbuf output</name>
  <files>userspace/iio_demo/src/main.rs</files>
  <action>
  Rewrite iio_demo to demonstrate kernel-level sensor filtering:

  1. Create a ringbuf map for valid sensor events
  2. Construct a BPF program that:
     - Reads the IioEvent.value field from context (R1 + offset of value field)
     - Checks if value is within valid range (e.g., 100-900 out of 0-999)
     - If OUT of range: return 0 (filtered/dropped)
     - If IN range: write event to ringbuf via bpf_ringbuf_output, return 1 (accepted)
     - This proves BPF can filter at kernel level before data reaches userspace
  3. Load program and attach to IIO (ATTACH_TYPE_IIO = 4)
  4. Userspace event loop:
     - Poll ringbuf for valid events
     - Print: "Sensor value=[X] (accepted)" for each valid event
     - Track: total events vs accepted events
     - Print periodic summary: "Filter stats: [X] accepted / [Y] total ([Z]% filtered)"
  5. Run for ~50 events then print summary and exit

  Read the existing iio_demo code and IioEvent struct layout first. The IioEvent fields and offsets need to match what the kernel sends.

  Read kernel/crates/kernel_bpf/src/attach/iio.rs to understand IioEvent struct layout for correct BPF offset calculations.

  Avoid: Don't modify the IIO driver or kernel — this is userspace-only work. The simulated accelerometer already generates events.
  </action>
  <verify>cargo build succeeds for both x86_64 and aarch64 targets</verify>
  <done>iio_demo filters simulated sensor data via BPF, outputs valid readings to ringbuf, tracks filter statistics</done>
</task>

<task type="auto">
  <name>Task 2: Wire IIO simulation into kernel init and verify in QEMU</name>
  <files>kernel/src/lib.rs, userspace/init/src/main.rs</files>
  <action>
  1. Check if IIO init is already called during kernel boot in kernel/src/lib.rs init().
     - Look for iio::init() or init_simulated_device() calls
     - If not present, add iio::init() and iio::init_simulated_device() to the init sequence
     - Place it after BPF manager init and before process spawning

  2. Update init to spawn iio_demo instead of safety_demo

  3. Build for x86_64 QEMU and test:
     - The simulated accelerometer should generate events
     - BPF program should filter them
     - Userspace should show accepted values and filter statistics

  4. Verify on QEMU serial output:
     - iio_demo loads BPF program
     - Events start flowing (simulated accelerometer)
     - Filter statistics show some events accepted, some filtered
     - No panics or errors

  Avoid: Don't modify the IIO simulation task — it already works. Just ensure it's started during boot.
  </action>
  <verify>QEMU serial shows: IIO BPF filter program loaded, sensor events filtered, statistics printed (e.g., "Filter: 80% of readings within range")</verify>
  <done>IIO sensor filtering demo runs on QEMU with simulated accelerometer, BPF filters at kernel level, userspace shows statistics</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] iio_demo compiles for both architectures
- [ ] IIO simulation wired into kernel boot
- [ ] BPF filter program rejects out-of-range values
- [ ] Accepted events visible via ringbuf in userspace
- [ ] Filter statistics printed (accepted vs total)
- [ ] Runs on QEMU without panics
</verification>

<success_criteria>

- IIO sensor filtering demo runs on QEMU
- BPF program filters sensor data at kernel level
- Only valid readings reach userspace via ringbuf
- Filter statistics demonstrate kernel-level filtering benefit
</success_criteria>

<output>
After completion, create `.planning/phases/03-benchmarks-validation/03-01-SUMMARY.md`
</output>
