---
phase: 01-bpf-end-to-end
plan: 03
type: execute
---

<objective>
Complete end-to-end BPF demo combining maps, ringbuf, and timer attach. Prove the full thesis: userspace loads verified program, kernel executes it on events, structured output flows back.

Purpose: Create a polished demo that proves Phase 1 is complete and serves as foundation for Phase 2 hardware demos.
Output: Demo program using array map counter + ringbuf event stream + timer, verified on QEMU.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bpf-end-to-end/01-01-SUMMARY.md
@.planning/phases/01-bpf-end-to-end/01-02-SUMMARY.md

**Key files:**
@userspace/bpf_loader/src/main.rs
@kernel/src/syscall/bpf.rs
@kernel/src/bpf/mod.rs
@kernel/src/bpf/helpers.rs
@kernel/crates/kernel_abi/src/bpf.rs

**Prior plan context:**
- Plan 01-01: BPF load + timer attach + trace_printk output working
- Plan 01-02: Ringbuf poll from userspace working
- Now: combine everything into a comprehensive demo
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build combined demo with array map counter + ringbuf event stream</name>
  <files>userspace/bpf_loader/src/main.rs</files>
  <action>
  Create a comprehensive BPF demo in bpf_loader that demonstrates the full Axiom BPF capability:

  1. Create an array map (type=array, key_size=4, value_size=8, max_entries=1) via sys_bpf(BPF_MAP_CREATE)
     - This map stores a tick counter

  2. Create a ringbuf map (type=ringbuf) via sys_bpf(BPF_MAP_CREATE)
     - This map streams events to userspace

  3. Construct a BPF program that on each timer tick:
     a. Reads the counter from array map via bpf_map_lookup_elem(map_id, key_ptr)
     b. Increments the counter
     c. Writes updated counter back via bpf_map_update_elem(map_id, key_ptr, value_ptr, flags)
     d. Writes an event to ringbuf via bpf_ringbuf_output(ringbuf_id, data_ptr, size, flags)
        - Event contains the current counter value
     e. Calls bpf_trace_printk for serial visibility
     f. Returns 0 and exits

  4. Load program via sys_bpf(BPF_PROG_LOAD), attach to timer

  5. Main loop:
     a. Poll ringbuf for events, display event data (counter values)
     b. Periodically read array map via sys_bpf(BPF_MAP_LOOKUP_ELEM) to show counter
     c. Print status: "Tick #N received via ringbuf, map counter: M"
     d. Sleep between iterations

  6. Print summary after N events showing the demo worked

  The program should clearly demonstrate:
  - BPF programs maintain state across invocations (via maps)
  - BPF programs can output structured events (via ringbuf)
  - Userspace can both observe (ringbuf) and query (map lookup) BPF state
  - All of this happens at timer interrupt level in the kernel

  Avoid: Don't make the BPF bytecode overly complex — keep it readable with clear comments explaining each instruction. Don't try to handle every edge case — this is a demo.
  </action>
  <verify>cargo build succeeds with the combined demo program</verify>
  <done>Demo program constructs BPF program using 3 helpers (map_lookup, map_update, ringbuf_output), creates 2 maps, and runs a userspace event loop</done>
</task>

<task type="auto">
  <name>Task 2: Verify on QEMU and document the demo</name>
  <files>userspace/init/src/main.rs</files>
  <action>
  1. Ensure the demo runs correctly on QEMU:
     - Build: cargo build (x86_64 target)
     - Run: cargo run (launches QEMU)
     - Observe serial output showing:
       a. "Creating array map... OK (id=0)"
       b. "Creating ringbuf... OK (id=1)"
       c. "Loading BPF program... OK (id=0)"
       d. "Attaching to timer... OK"
       e. Repeated: "Tick #1 received" / "Tick #2 received" / etc.
       f. Map counter values matching tick count

  2. If running on AArch64 virt, also verify with scripts/run-virt.sh

  3. Fix any issues found during verification:
     - BPF instruction encoding errors
     - Map/ringbuf creation failures
     - Helper call mismatches
     - Userspace copy issues

  4. Update init if needed to properly exec bpf_loader

  5. Verify no kernel panics, no BPF errors, clean output

  Avoid: Don't spend time on AArch64 RPi5 testing — that's Phase 2. QEMU verification is sufficient.
  </action>
  <verify>QEMU serial shows: maps created, program loaded, timer attached, tick events flowing via ringbuf with incrementing counter — full pipeline proven</verify>
  <done>End-to-end BPF demo runs on QEMU showing maps + ringbuf + timer attach working together. Phase 1 complete.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Array map created and readable from userspace
- [ ] Ringbuf map created and pollable from userspace
- [ ] BPF program uses 3+ helper functions (map ops + ringbuf)
- [ ] Timer tick counter increments correctly
- [ ] Ringbuf events received in userspace
- [ ] Demo runs cleanly on QEMU without panics
- [ ] All existing cargo tests still pass
</verification>

<success_criteria>

- All tasks completed
- Full BPF pipeline proven: load → verify → attach → execute → maps → ringbuf → userspace
- Demo output is clean and demonstrates the core Axiom thesis
- Phase 1 complete, ready for Phase 2 (hardware attach points)
</success_criteria>

<output>
After completion, create `.planning/phases/01-bpf-end-to-end/01-03-SUMMARY.md`:

# Phase 1 Plan 3: End-to-End BPF Demo Summary

**[Substantive one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Phase Readiness

Phase 1 complete. Ready for Phase 2: RPi5 Hardware Demos.
- BPF load/attach/execute pipeline proven
- Ringbuf userspace delivery working
- Map operations from both BPF and userspace verified
- Foundation established for GPIO/PWM attach points
</output>
