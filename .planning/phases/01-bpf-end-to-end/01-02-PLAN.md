---
phase: 01-bpf-end-to-end
plan: 02
type: execute
---

<objective>
Wire BPF ringbuf output from kernel to userspace so BPF programs can stream events to user applications.

Purpose: Enable the observation pipeline — BPF programs produce events, userspace consumes and displays them. This is essential for tracing demos in Phase 2.
Output: sys_bpf supports ringbuf polling, demo program writes events from BPF and reads them in userspace.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bpf-end-to-end/01-01-SUMMARY.md

**Key files:**
@kernel/src/syscall/bpf.rs
@kernel/src/bpf/mod.rs
@kernel/crates/kernel_bpf/src/maps/ringbuf.rs
@kernel/crates/kernel_bpf/src/maps/mod.rs
@kernel/src/bpf/helpers.rs
@kernel/crates/kernel_abi/src/bpf.rs
@userspace/minilib/src/lib.rs

**Prior plan context:**
- Plan 01-01 proved BPF load → attach → timer execute pipeline
- bpf_trace_printk works for serial output
- Now need ringbuf for structured event delivery to userspace

**Technical context:**
- RingBufMap has poll() method that returns Option<Vec<u8>> — reads and advances tail
- bpf_ringbuf_output helper (in kernel/src/bpf/helpers.rs) writes events to ringbuf
- BpfManager has ringbuf_output(map_id, data, flags) method
- sys_bpf already handles BPF_MAP_CREATE (cmd=1) for ringbuf type
- BPF_MAP_LOOKUP_ELEM (cmd=2) exists but returns raw pointer — not suitable for ringbuf polling
- Need new command or extend existing for ringbuf poll semantics
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BPF ringbuf poll command to sys_bpf</name>
  <files>kernel/src/syscall/bpf.rs, kernel/src/bpf/mod.rs, kernel/crates/kernel_abi/src/bpf.rs</files>
  <action>
  Add a new sys_bpf command for userspace to poll events from a ringbuf map.

  1. Add constant `BPF_RINGBUF_POLL = 10` (or next available) in kernel_abi/src/bpf.rs

  2. In kernel/src/syscall/bpf.rs, add a handler for BPF_RINGBUF_POLL:
     - Parse attr to get: map_id (which ringbuf to poll), buf_ptr (userspace buffer to write event data), buf_size (buffer capacity)
     - Lock BPF_MANAGER, call poll on the ringbuf map identified by map_id
     - If event available: copy event data to userspace buffer via copy_to_userspace, return event data length
     - If no event: return 0 (or -EAGAIN)
     - If buffer too small: return -ENOSPC

  3. In kernel/src/bpf/mod.rs, add a method `ringbuf_poll(map_id: u32) -> Option<Vec<u8>>` to BpfManager that:
     - Looks up the map by ID
     - Downcast to RingBufMap
     - Calls poll() on it
     - Returns the event data

  Read kernel/crates/kernel_bpf/src/maps/ringbuf.rs poll() to understand the return format. Read existing sys_bpf handlers (BPF_MAP_LOOKUP_ELEM) for the userspace copy pattern.

  Avoid: Don't implement mmap-based sharing — simple poll-and-copy is sufficient for demos. Don't add new syscalls — extend sys_bpf with a new command number.
  </action>
  <verify>cargo build succeeds with new BPF_RINGBUF_POLL command, cargo test -p kernel_bpf passes</verify>
  <done>sys_bpf(BPF_RINGBUF_POLL) copies next ringbuf event to userspace buffer, returns data length or 0 if empty</done>
</task>

<task type="auto">
  <name>Task 2: Create demo: BPF writes to ringbuf on timer, userspace polls and prints</name>
  <files>userspace/bpf_loader/src/main.rs, userspace/minilib/src/lib.rs</files>
  <action>
  Extend bpf_loader (or create a new demo) to demonstrate the full ringbuf pipeline:

  1. Create a ringbuf map via sys_bpf(BPF_MAP_CREATE) with type=ringbuf, appropriate size
     - Map ID returned on success

  2. Construct a BPF program that:
     - Calls bpf_ringbuf_output(map_id, data_ptr, data_size, 0) to write an event
     - The event data can be simple (e.g., a counter or timestamp)
     - Exits with return code 0

  3. Load the program via sys_bpf(BPF_PROG_LOAD)
  4. Attach to timer via sys_bpf(BPF_PROG_ATTACH)

  5. In a loop, poll the ringbuf:
     - Call sys_bpf(BPF_RINGBUF_POLL) with buffer
     - If data received, format and print to serial via write()
     - Sleep briefly between polls to avoid busy-waiting
     - Show event count and data

  6. Add minilib wrapper for the new BPF_RINGBUF_POLL command if needed.

  The BPF program needs to know the map_id to pass to bpf_ringbuf_output. This can be hardcoded (map_id=0 if it's the first map created) or passed via program context.

  Avoid: Don't over-engineer the event format — a simple 8-byte counter or timestamp is enough. Don't implement complex event parsing.
  </action>
  <verify>QEMU serial output shows: map created, program loaded, program attached, then repeated "Event received: [data]" messages from ringbuf polling</verify>
  <done>Full ringbuf pipeline working: BPF writes events on timer tick → userspace polls and displays event data on serial</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] BPF_RINGBUF_POLL command added to sys_bpf
- [ ] Ringbuf map created from userspace
- [ ] BPF program writes events to ringbuf on timer tick
- [ ] Userspace successfully polls events from ringbuf
- [ ] Event data displayed on serial console
- [ ] cargo test passes (existing tests not broken)
</verification>

<success_criteria>

- sys_bpf supports ringbuf polling from userspace
- BPF program → ringbuf → userspace event delivery works
- Events visible on QEMU serial console
- No kernel panics or data corruption
</success_criteria>

<output>
After completion, create `.planning/phases/01-bpf-end-to-end/01-02-SUMMARY.md`
</output>
