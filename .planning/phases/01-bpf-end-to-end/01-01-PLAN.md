---
phase: 01-bpf-end-to-end
plan: 01
type: execute
---

<objective>
Prove BPF programs can be loaded from userspace and execute on timer interrupts with visible output.

Purpose: Validate the core BPF pipeline works end-to-end before wiring hardware attach points.
Output: bpf_loader loads a BPF program that calls bpf_trace_printk, attaches to timer, output visible on QEMU serial console.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md

**Key files:**
@userspace/bpf_loader/src/main.rs
@kernel/src/bpf/helpers.rs
@kernel/src/syscall/bpf.rs
@kernel/src/bpf/mod.rs
@kernel/crates/kernel_abi/src/bpf.rs
@kernel/crates/kernel_bpf/src/bytecode/insn.rs
@kernel/crates/kernel_bpf/src/bytecode/opcode.rs
@userspace/minilib/src/lib.rs

**Discovery findings:**
- AArch64 userspace boots and runs init — NOT a blocker
- sys_bpf fully implements BPF_PROG_LOAD (raw bytecode) and BPF_PROG_LOAD_ELF
- BPF Manager has load_raw_program(), attach(), execute_hooks() all working
- Timer interrupt handler calls execute_hooks(ATTACH_TYPE_TIMER=1) on both x86_64 and AArch64
- bpf_trace_printk helper outputs to kernel serial log
- Current bpf_loader only loads a trivial 2-instruction program (mov r0, 42; exit)
- BPF instructions are available in kernel_abi::bpf::BpfInsn

**Constraining context:**
- BPF programs are constructed as raw BpfInsn arrays in userspace (no C→BPF cross-compilation needed)
- Helper function numbers match extern "C" function names (bpf_trace_printk = helper 6 per execution/interpreter.rs)
- BPF CALL instruction: opcode 0x85, imm = helper function number
- BPF programs must end with EXIT instruction (opcode 0x95)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance bpf_loader to load a program that calls bpf_trace_printk and attach to timer</name>
  <files>userspace/bpf_loader/src/main.rs</files>
  <action>
  Rewrite bpf_loader to:

  1. Construct a BPF program (as BpfInsn array) that:
     - Calls bpf_trace_printk helper to output a message (e.g., "BPF tick!")
     - The helper number for bpf_trace_printk needs to be determined from the interpreter's helper dispatch table in kernel/src/bpf/helpers.rs and kernel/crates/kernel_bpf/src/execution/interpreter.rs
     - Returns 0 and exits

  2. Load the program via sys_bpf(BPF_PROG_LOAD=5, attr) where attr contains:
     - prog_type: appropriate type (e.g., 1 for SocketFilter or whatever the timer expects)
     - insn_cnt: number of instructions
     - insns: pointer to instruction array
     - Returns program ID (fd) on success

  3. Attach the program to timer via sys_bpf(BPF_PROG_ATTACH=8, attr) where attr contains:
     - target_fd: ATTACH_TYPE_TIMER (1)
     - attach_bpf_fd: program ID from load step

  4. Print success/failure messages via minilib write()
  5. Sleep or loop to let timer ticks fire and show output

  Read the existing bpf_loader code first to understand the BpfAttr structure and calling convention. Read kernel/src/syscall/bpf.rs to understand how BPF_PROG_ATTACH parses the attr fields. Read kernel/src/bpf/helpers.rs to find the correct helper function number for bpf_trace_printk.

  Avoid: Don't use BPF_PROG_LOAD_ELF (cmd=9) — use raw bytecode loading (cmd=5) since we're constructing instructions directly. Don't try to pass format string pointers from userspace into BPF — bpf_trace_printk in this kernel uses a fixed format.
  </action>
  <verify>cargo build (AArch64 or x86_64 target) succeeds with updated bpf_loader</verify>
  <done>bpf_loader constructs a multi-instruction BPF program with helper call, loads it via sys_bpf, attaches to timer, and prints status messages</done>
</task>

<task type="auto">
  <name>Task 2: Run on QEMU and verify trace output appears on serial console</name>
  <files>userspace/init/src/main.rs</files>
  <action>
  1. Ensure bpf_loader is included in the disk image. Check userspace/file_structure/src/lib.rs — add bpf_loader to the STRUCTURE if it's not already there. Add the corresponding artifact dependency in Cargo.toml if needed (follow the pattern of existing demos like gpio_demo).

  2. Modify init to spawn/exec bpf_loader (or have init call it directly). Read the current init code to understand how it works — it may just print hello and exit. Modify it to execve("/bin/bpf_loader") or inline the bpf_loader logic.

  3. Build the full kernel with disk image: `cargo build` (for x86_64) or the AArch64 equivalent.

  4. Run in QEMU and check serial output. Use `cargo run` for x86_64 or `scripts/run-virt.sh` for AArch64.

  5. Verify that:
     - Kernel boots and starts init
     - bpf_loader loads the BPF program (success message printed)
     - Timer ticks fire and bpf_trace_printk output appears on serial console repeatedly
     - No panics or errors

  If bpf_trace_printk doesn't produce visible output, check if the helper is being called correctly by reading interpreter.rs dispatch. May need to use log::info! level which goes to serial.

  Avoid: Don't modify the kernel BPF subsystem — this plan only changes userspace code. If something doesn't work, debug the userspace side first.
  </action>
  <verify>QEMU serial output shows repeated BPF trace messages from timer interrupt, proving the pipeline: userspace load → kernel verify → timer attach → interrupt execute → serial output</verify>
  <done>BPF program loaded from userspace fires on every timer tick with visible serial output in QEMU</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] bpf_loader compiles and is included in disk image
- [ ] Kernel boots to init on QEMU
- [ ] bpf_loader loads BPF program (success message visible)
- [ ] Timer-attached BPF program executes repeatedly (trace output visible)
- [ ] No kernel panics or BPF errors
</verification>

<success_criteria>

- BPF program with helper call constructed in userspace
- Program loaded via sys_bpf and attached to timer
- Repeated trace output visible on QEMU serial console
- Works on at least one architecture (x86_64 or AArch64)
</success_criteria>

<output>
After completion, create `.planning/phases/01-bpf-end-to-end/01-01-SUMMARY.md`
</output>
