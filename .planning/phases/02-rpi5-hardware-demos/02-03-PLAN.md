---
phase: 02-rpi5-hardware-demos
plan: 03
type: execute
---

<objective>
Demonstrate safety interlock: limit switch GPIO interrupt → BPF program → motor emergency stop, with zero userspace dependency.

Purpose: Prove the safety thesis — kernel-level safety interlocks that cannot be bypassed even if userspace crashes. The interrupt→BPF→hardware path has no userspace in the loop.
Output: safety_interlock demo on RPi5 where limit switch triggers BPF motor stop, even after userspace exits.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rpi5-hardware-demos/02-01-SUMMARY.md
@.planning/phases/02-rpi5-hardware-demos/02-02-SUMMARY.md

**Key files:**
@kernel/src/bpf/helpers.rs
@kernel/src/arch/aarch64/platform/rpi5/gpio.rs
@kernel/src/arch/aarch64/platform/rpi5/pwm.rs
@userspace/safety_demo/src/main.rs
@userspace/gpio_demo/src/main.rs
@kernel/src/bpf/mod.rs

**Prior context:**
- Plan 02-01: Lock-free BPF execution in GPIO handler, GPIO→BPF→LED proven
- Plan 02-02: PWM tracing with timestamps proven
- bpf_motor_emergency_stop helper: sets all 4 PWM channels to 0% duty
- GPIO interrupt handler calls BPF hooks on edge events
- Safety path: GPIO IRQ → GIC → handle_interrupt() → BPF execute → bpf_motor_emergency_stop
- This entire path is in kernel interrupt context — userspace is NOT in the loop
- BPF programs persist after the loading process exits (attached to kernel hooks)

**Key insight for safety demo:**
The BPF program is loaded and attached by userspace, then userspace can EXIT. The program remains attached to the GPIO interrupt handler. When the limit switch triggers, the kernel executes the BPF program directly — no userspace involvement. This is the core safety guarantee.

**Branch:** phase2-rpi5-hardware-demos
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create safety interlock demo program</name>
  <files>userspace/safety_demo/src/main.rs, userspace/init/src/main.rs</files>
  <action>
  Create (or enhance existing) safety_demo that demonstrates the safety interlock:

  1. Read existing safety_demo/src/main.rs to see what's already there.

  2. The demo should:
     a. Print banner: "Axiom Safety Interlock Demo"
     b. Start PWM on a channel (e.g., PWM0 channel 1) at 50% duty — simulating a running motor
        - Use bpf_pwm_write helper or direct PWM syscall if available
        - If no PWM syscall exists, construct a BPF program that sets PWM via timer
     c. Create a BPF program for GPIO interrupt (limit switch on configurable pin, e.g., pin 22):
        - On rising edge: call bpf_motor_emergency_stop(reason=1)
        - Also call bpf_trace_printk to log "SAFETY: Motor stopped by limit switch!"
        - Return 0
     d. Load the BPF program via sys_bpf(BPF_PROG_LOAD)
     e. Attach to GPIO via sys_bpf(BPF_PROG_ATTACH, ATTACH_TYPE_GPIO)
     f. Enable GPIO interrupt on the limit switch pin (rising edge)
        - This may require a new syscall or helper to configure GPIO interrupt from userspace
        - Check if gpio_demo already does this, and follow its pattern
     g. Print: "Safety interlock armed. Motor running. BPF program attached to GPIO."
     h. Print: "Userspace will now EXIT. Safety remains in kernel."
     i. Call exit(0) — demonstrating that the safety program survives process exit
     j. The BPF program continues to execute on GPIO interrupts after userspace exits

  3. Update init to exec safety_demo.

  Read gpio_demo first — it likely has the GPIO interrupt enable pattern. The key difference is that safety_demo explicitly exits to prove the kernel-level safety guarantee.

  For the GPIO interrupt enable: check if there's a syscall for enabling GPIO interrupts, or if the demo programs embed this in their BPF programs. If GPIO interrupt configuration must be done from kernel init, add it to the RPi5 platform init code.

  Avoid: Don't add new kernel subsystems. Use existing GPIO interrupt infrastructure and BPF helpers. Keep the demo focused on proving the safety thesis.
  </action>
  <verify>cargo build --target aarch64-unknown-none --features "aarch64_arch,rpi5" succeeds with safety_demo</verify>
  <done>Safety interlock demo: loads BPF motor-stop program, attaches to GPIO, exits. Program survives in kernel.</done>
</task>

<task type="auto">
  <name>Task 2: Build for RPi5 and deploy</name>
  <files>scripts/build-rpi5.sh</files>
  <action>
  1. Build for RPi5: scripts/build-rpi5.sh
  2. Verify kernel8.img created
  3. Ensure safety_demo is in disk image

  Avoid: Don't test in QEMU.
  </action>
  <verify>RPi5 kernel8.img built with safety_demo as startup program</verify>
  <done>RPi5 build ready for deployment with safety interlock demo</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>RPi5 kernel with safety interlock demo. BPF program attached to GPIO fires bpf_motor_emergency_stop on limit switch, even after userspace exits.</what-built>
  <how-to-verify>
    1. Deploy: Run `scripts/deploy-rpi5.sh`
    2. Hardware setup:
       - Limit switch (or button simulating one) on GPIO pin 22 (or configured pin)
       - PWM output on PWM0 channel 1 (can monitor with oscilloscope or LED)
       - LED on GPIO 18 for visual feedback (optional)
    3. Boot: Insert SD card, power on RPi5
    4. Observe serial console:
       - safety_demo starts, motor PWM enabled
       - "Safety interlock armed" message
       - "Userspace will now EXIT" — process exits
       - Kernel continues running (timer ticks visible)
    5. Trigger: Press limit switch / activate button on GPIO 22
    6. Verify on serial: "SAFETY: Motor stopped by limit switch!" from BPF trace_printk
    7. Verify: PWM duty cycle drops to 0% (motor stops)
    8. Key test: The motor stop happened AFTER userspace exited — proving kernel-level safety
    9. Stress test: Press limit switch multiple times — should handle cleanly each time
  </how-to-verify>
  <resume-signal>Type "approved" if safety interlock works after userspace exit, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Safety interlock BPF program loads and attaches to GPIO
- [ ] Userspace exits cleanly after arming interlock
- [ ] Limit switch triggers BPF motor emergency stop in kernel
- [ ] Motor stops (PWM duty → 0%) on limit switch activation
- [ ] Works even after userspace process has exited
- [ ] No kernel panics or deadlocks
</verification>

<success_criteria>

- Safety interlock demo runs on real RPi5
- BPF motor-stop program survives userspace exit
- Limit switch → kernel BPF → motor stop with zero userspace dependency
- Proves: "safety interlocks enforced by kernel, cannot be bypassed"
- Phase 2 complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-rpi5-hardware-demos/02-03-SUMMARY.md`:

Phase 2 complete. Ready for Phase 3: Benchmarks & Validation.
- GPIO→BPF→LED proven on RPi5
- PWM tracing with nanosecond timestamps proven
- Safety interlock (interrupt→BPF→hardware, no userspace) proven
</output>
