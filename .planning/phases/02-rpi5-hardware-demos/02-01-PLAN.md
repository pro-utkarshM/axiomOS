---
phase: 02-rpi5-hardware-demos
plan: 01
type: execute
---

<objective>
Fix the BPF manager deadlock in all non-timer hook handlers and prove GPIO→BPF→LED works on real RPi5 hardware.

Purpose: Unblock all BPF attach points (GPIO, PWM, IIO, syscall) for safe execution, then validate the GPIO demo on physical hardware.
Output: Lock-free execution in all hook handlers, gpio_demo running on RPi5 with button→BPF→LED.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bpf-end-to-end/01-02-SUMMARY.md

**Key files:**
@kernel/src/bpf/mod.rs
@kernel/src/arch/aarch64/platform/rpi5/gpio.rs
@kernel/src/arch/aarch64/interrupts.rs
@kernel/src/driver/iio.rs
@kernel/src/syscall/mod.rs
@kernel/src/arch/aarch64/platform/rpi5/pwm.rs
@userspace/gpio_demo/src/main.rs
@userspace/init/src/main.rs
@scripts/build-rpi5.sh
@scripts/deploy-rpi5.sh

**Prior context (Phase 1):**
- Lock-free pattern established in 01-02: `get_hook_programs()` clones programs, `execute_program()` runs without lock
- Timer handlers already fixed (idt.rs and interrupts.rs timer paths)
- Deadlock-prone sites remaining: GPIO handler (gpio.rs:385-390), PWM trigger (pwm.rs:232-254), IIO dispatch (iio.rs:68-72), syscall tracing (syscall/mod.rs:95-96)
- All use `manager.lock().execute_hooks()` which holds lock during BPF execution
- gpio_demo already written: button on pin 17, LED on pin 18, BPF toggles LED on rising edge

**Branch:** phase2-rpi5-hardware-demos (merge to dev when Phase 2 complete)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply lock-free BPF execution pattern to GPIO, PWM, IIO, and syscall handlers</name>
  <files>kernel/src/arch/aarch64/platform/rpi5/gpio.rs, kernel/src/arch/aarch64/platform/rpi5/pwm.rs, kernel/src/driver/iio.rs, kernel/src/syscall/mod.rs</files>
  <action>
  Apply the same lock-free pattern used in the timer interrupt handler (from Plan 01-02) to all four remaining hook call sites.

  The pattern (from kernel/src/arch/aarch64/interrupts.rs timer handler):
  1. Lock BPF_MANAGER briefly to clone attached programs via get_hook_programs(attach_type)
  2. Drop the lock immediately
  3. Execute each cloned program via BpfManager::execute_program() (static method, no lock needed)

  Apply to these four files:

  **1. GPIO handler** (kernel/src/arch/aarch64/platform/rpi5/gpio.rs):
  - Find the `execute_hooks(ATTACH_TYPE_GPIO, &ctx)` call in handle_interrupt()
  - Replace with: get_hook_programs(ATTACH_TYPE_GPIO), drop lock, iterate and execute_program()
  - Pass the GpioEvent context through

  **2. PWM trigger** (kernel/src/arch/aarch64/platform/rpi5/pwm.rs):
  - Find the `execute_hooks(ATTACH_TYPE_PWM, &ctx)` call in trigger_event()
  - Replace with same pattern
  - Pass the PwmEvent context through

  **3. IIO dispatch** (kernel/src/driver/iio.rs):
  - Find the `execute_hooks(ATTACH_TYPE_IIO, &ctx)` call
  - Replace with same pattern

  **4. Syscall tracing** (kernel/src/syscall/mod.rs):
  - Find the `execute_hooks(ATTACH_TYPE_SYSCALL, &ctx)` call
  - Replace with same pattern

  Read the timer handler in kernel/src/arch/aarch64/interrupts.rs first to see the exact pattern to replicate. Read each target file before modifying.

  Avoid: Don't change the execute_hooks() method itself — other code may depend on it. Add the lock-free pattern at each call site.
  </action>
  <verify>cargo build --target aarch64-unknown-none --features "aarch64_arch,rpi5" succeeds. Also verify cargo build for x86_64 (syscall handler is cross-platform).</verify>
  <done>All four hook call sites use lock-free BPF execution pattern. No deadlock possible when BPF programs use map/ringbuf helpers.</done>
</task>

<task type="auto">
  <name>Task 2: Build for RPi5 and prepare gpio_demo for deployment</name>
  <files>userspace/init/src/main.rs, userspace/file_structure/src/lib.rs</files>
  <action>
  1. Ensure gpio_demo is in the disk image file structure. Check userspace/file_structure/src/lib.rs — gpio_demo should already be listed. If not, add it.

  2. Modify init to exec gpio_demo instead of bpf_loader:
     - Read current init/src/main.rs
     - Change execve target to "/bin/gpio_demo"

  3. Build for RPi5:
     - Run: scripts/build-rpi5.sh (or the equivalent cargo build command with rpi5 feature)
     - This produces kernel8.img for RPi5

  4. Verify the build succeeds and kernel8.img is created.

  Avoid: Don't modify the gpio_demo program itself — it's already written. Don't try to test in QEMU — GPIO requires real hardware.
  </action>
  <verify>RPi5 kernel8.img built successfully, gpio_demo included in disk image, init configured to spawn gpio_demo</verify>
  <done>RPi5 build ready for deployment with gpio_demo as the startup program</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>RPi5 kernel with GPIO→BPF→LED demo. Lock-free BPF execution in all handlers.</what-built>
  <how-to-verify>
    1. Deploy: Run `scripts/deploy-rpi5.sh` to flash kernel8.img to SD card
    2. Hardware: Connect button to GPIO pin 17 (with pull-down resistor), LED to GPIO pin 18 (with current-limiting resistor)
    3. Boot: Insert SD card, power on RPi5
    4. Observe: Serial console should show kernel boot, gpio_demo starting, BPF program loading
    5. Test: Press the button — LED should toggle on each press
    6. Verify: Serial output shows "GPIO BPF Hook" messages on each button press
    7. Confirm: LED toggles reliably, no kernel panics, no freezes (deadlock fixed)
  </how-to-verify>
  <resume-signal>Type "approved" if LED toggles on button press, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All four hook handlers use lock-free pattern
- [ ] RPi5 build succeeds
- [ ] gpio_demo deploys and runs on real RPi5
- [ ] Button press toggles LED via BPF
- [ ] No deadlocks or kernel panics
</verification>

<success_criteria>

- Lock-free BPF execution in GPIO, PWM, IIO, and syscall handlers
- gpio_demo runs on real RPi5 hardware
- Button→BPF→LED pipeline proven on physical hardware
- No deadlocks when BPF programs use map/ringbuf helpers
</success_criteria>

<output>
After completion, create `.planning/phases/02-rpi5-hardware-demos/02-01-SUMMARY.md`
</output>
